<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>AI Assistants</title>

    <link href="https://fastly.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
    <link href="https://fastly.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/dist/tippy.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/min/dropzone.min.css" integrity="sha512-WvVX1YO12zmsvTpUQV8s7ZU98DnkaAokcciMZJfnNWyNzm7//QRV61t4aEr0WdIa4pe854QHLTV302vH92FSMw==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        body {
            height: 100vh;
            margin: 0;
        }
        #assistants-list {
            overflow-y: auto;
        }
        #conversation {
            height: calc(100vh - 168px); /* Adjust based on navbar height */
            overflow-y: auto;
        }
        #question-form {
            display: flex;
        }
        #question {
            flex-grow: 1;
            margin-right: 10px;
        }
        #loading-conversation {
            text-align: center;
            margin: 40px;
        }
        #no-messages {
            text-align: center;
            margin: 40px;
        }
        .assistant-item {
            position: relative;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .assistant-info-icon {
            margin-left: 10px;
            cursor: pointer;
        }
        .assistant-details {
            display: none;
        }
        /* Add a higher z-index for assistant tooltips */
        .tippy-box {
            z-index: 9999;
        }
        /* Style the assistant tooltip */
        .tippy-box[data-theme~='light'] {
            background-color: white;
            color: black;
            border: 1px solid #ccc;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding-top: 16px;
        }
        /* Customize the arrow to be white */
        .tippy-box[data-theme~='light'][data-placement^='top'] > .tippy-arrow::before {
            border-top-color: white;
        }
        .tippy-box[data-theme~='light'][data-placement^='bottom'] > .tippy-arrow::before {
            border-bottom-color: white;
        }
        .tippy-box[data-theme~='light'][data-placement^='left'] > .tippy-arrow::before {
            border-left-color: white;
        }
        .tippy-box[data-theme~='light'][data-placement^='right'] > .tippy-arrow::before {
            border-right-color: white;
        }
        .user-message {
            width: 70%;
            margin-left: auto;
            background-color: #cfe2ff;
            border-color: transparent;
        }
        .assistant-message {
            width: 100%;
            margin-right: auto;
        }
        .list-group-item.active {
            background-color: #052c65;
            border-color: #052c65;
        }
        .dropzone {
            border: 2px dashed #007bff;
            border-radius: 5px;
            background: #f8f9fa;
            padding: 20px;
            text-align: center;
        }
        .dropzone .dz-message {
            font-weight: bold;
            color: #007bff;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.min.js'></script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/min/dropzone.min.js" integrity="sha512-oQq8uth41D+gIH/NJvSJvVB85MFk1eWpMK6glnkg6I7EdMqC1XVkW7RxLheXwmFdG03qScCM7gKS/Cx3FYt7Tg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

</head>
<body>


<nav class="navbar bg-body-tertiary">
    <div class="container">
        <a class="navbar-brand" href="#">
            <span class="text-muted">Assistants</span>
        </a>

        <div class="d-flex">

            <div class="btn-group" role="group" aria-label="Basic example">
                <button class="btn btn-outline-secondary" onclick="downloadMessagesDocx()"
                       tabindex="0" data-bs-toggle="popover" data-bs-trigger="hover focus" data-bs-placement="auto"
                       data-bs-content="Click to download thread messages as a word file.">
                    <i class="bi bi-filetype-docx"></i>
                </button>
                <button class="btn btn-outline-secondary" onclick="downloadMessagesMd()"
                       tabindex="0" data-bs-toggle="popover" data-bs-trigger="hover focus" data-bs-placement="auto"
                       data-bs-content="Click to download thread messages as a markdown file.">
                    <i class="bi bi-filetype-md"></i>
                </button>
            </div>


            <button class="btn btn-outline-danger ms-2" onclick="resetThread()"
                   tabindex="0" data-bs-toggle="popover" data-bs-trigger="hover focus" data-bs-placement="auto"
                   data-bs-content="Click to reset this thread.">
                <i class="bi bi-x-lg"></i>
            </button>

        </div>

    </div>
</nav>


<div id="content" class="container mt-3">

    <div class="row">

        <div class="col-4">

            <div id="assistants-list" class="list-group">
                <div id="assistants-container" class="list-group">
                    <div id="loading-assistants">
                        <span class="spinner-border spinner-border-sm" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </span> Loading assistants...
                    </div>
                </div>
            </div>

            <ul id="file-list" class="list-group mt-3">
                <li class="list-group-item list-group-item-light">Data files</li>
            </ul>

            <div id="dropzone" class="dropzone mt-3"></div>

        </div>


        <div class="col-8">

            <div id="conversation">

                <div id="loading-conversation">
                    <span class="spinner-border spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </span> Loading conversation...
                </div>

            </div>

        </div>

    </div>

</div>


<nav class="navbar fixed-bottom bg-body-white">
    <div class="container">
        <div id="question-form" class="offset-4 w-100 my-2 ps-2">
            <textarea id="question" class="form-control" rows="2" placeholder="Type your question here..."></textarea>
            <button id="submit-btn" class="btn btn-secondary" onclick="submitQuestion()">Submit</button>
        </div>
    </div>
</nav>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js" integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            var popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
            var popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
                return new bootstrap.Popover(popoverTriggerEl);
            });

            document.getElementById('question').addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    if (e.shiftKey) {
                        // Allow new line if Shift key is pressed
                        return;
                    } else {
                        e.preventDefault();
                        // Submit the question
                        submitQuestion();
                    }
                }
            });
        });

        let selectedAssistantId = null;
        let selectedAssistantName = null;
        let assistantDictionary = {};
        let threadId = sessionStorage.getItem('threadId');
        const noMessagesDiv = `
                    <div id="no-messages">
                        <p>No messages in this thread yet.</p>
                        <p>Start the conversation by asking a question.</p>
                    </div>
                `;

        // Function to get the project key from the URL hash parameter
        function getProjectKeyFromURL() {
            const hash = window.location.hash;
            if (hash.startsWith('#')) {
                return hash.substring(1);
            }
            return null;
        }

        // Function to fetch the list of assistants
        async function fetchAssistants() {
            const projectKey = getProjectKeyFromURL();
            if (!projectKey) {
                document.getElementById('assistants-container').innerText = 'Project key not found in URL.';
                document.getElementById('conversation').innerText = '';
                return;
            }

            const url = 'https://api.openai.com/v1/assistants';
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();

                if (!data.data) {
                    throw new Error('Assistants data is not defined');
                }

                displayAssistants(data.data);

                return data.data;  // Return the assistants data

            } catch (error) {
                console.error('Error fetching assistants:', error);
                document.getElementById('assistants-list').innerText = `Failed to fetch assistants: ${error.message}`;
            }
        }

        // Function to display the list of assistants
        function displayAssistants(assistants) {
            const containerElement = document.getElementById('assistants-container');
            containerElement.innerHTML = '';

            if (assistants.length === 0) {
                containerElement.innerText = 'No assistants found.';
                return;
            }

            assistants.reverse().forEach((assistant, index) => {
                assistantDictionary[assistant.id] = assistant.name;

                const description = assistant.description ? `<span class="small">${assistant.description}</span>` : '';
                const instructions = assistant.instructions ? `<p><strong>Instructions:</strong> ${assistant.instructions}</p>` : '';
                const model = assistant.model ? `<p><strong>Model:</strong> ${assistant.model}</p>` : '';
                const tools = assistant.tools && assistant.tools.length > 0 ?
                    `<p><strong>Tools:</strong> ${assistant.tools.map(tool => tool.type).join(', ')}</p>` : '';

                const assistantElement = document.createElement('a');
                assistantElement.className = 'list-group-item list-group-item-action assistant-item';
                assistantElement.innerHTML = `
                    <div>
                        <strong class="d-block">${assistant.name}</strong>
                        ${description}
                    </div>
                    <i class="bi bi-info-circle assistant-info-icon" tabindex="0"></i>
                    <div class="assistant-details" style="display:none;">
                        ${instructions}${model}${tools}
                    </div>
                `;
                assistantElement.onclick = () => selectAssistant(assistant.id, assistant.name, assistantElement);
                containerElement.appendChild(assistantElement);

                // Initialize Tippy.js tooltips
                tippy(assistantElement.querySelector('.assistant-info-icon'), {
                    content: assistantElement.querySelector('.assistant-details').innerHTML,
                    allowHTML: true,
                    interactive: true,
                    placement: 'auto',
                    theme: 'light',
                    appendTo: document.body
                });

                // Select the first assistant by default
                if (index === 0) {
                    selectAssistant(assistant.id, assistant.name, assistantElement);
                }
            });

            containerElement.style.overflow = 'visible';
        }

        // Function to select an assistant
        function selectAssistant(assistantId, assistantName, element) {
            selectedAssistantId = assistantId;
            selectedAssistantName = assistantName;

            // Set the selected assistant element as active
            const assistantElements = document.querySelectorAll('.list-group-item');
            assistantElements.forEach(el => el.classList.remove('active'));
            element.classList.add('active');

            console.log(`Selected Assistant ID: ${assistantId}`);
        }

        // Function to scroll to the bottom of the conversation
        function scrollToBottom() {
            const conversationElement = document.getElementById('conversation');
            conversationElement.scrollTop = conversationElement.scrollHeight;
        }

        // Function to submit a question
        async function submitQuestion() {
            const projectKey = getProjectKeyFromURL();
            const questionText = document.getElementById('question').value.trim();

            // Check if the textarea is not empty before submitting
            if (!selectedAssistantId || !questionText) {
                alert('Please select an assistant and enter a question.');
                return;
            }

            // Remove the no-messages div if it exists
            const noMessagesDiv = document.getElementById('no-messages');
            if (noMessagesDiv) {
                noMessagesDiv.remove();
            }

            // Disable submit button and add spinner
            const submitButton = document.getElementById('submit-btn');
            submitButton.disabled = true;
                submitButton.innerHTML = 'Submit <div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Loading...</span></div>';

            displayMessage('user', questionText);

            await addQuestionToThread(projectKey, questionText);

            document.getElementById('question').value = '';

            // Create an empty assistant response element
            const assistantResponseElement = renderAssistantMessageElement(selectedAssistantName, '');
            document.getElementById('conversation').appendChild(assistantResponseElement);

            const responseTextElement = assistantResponseElement.querySelector('div.card-body');
            await createRun(projectKey, responseTextElement);

            // Enable submit button and remove spinner
            submitButton.disabled = false;
            submitButton.innerHTML = 'Submit';
        }

        function renderUserMessageElement(text) {
            const messageElement = document.createElement('div');
            messageElement.className = 'message user-message alert alert-light mb-3';
            messageElement.innerHTML = `<strong>${text}</strong>`;
            return messageElement;
        }

        function renderAssistantMessageElement(assistantName, text) {
            const messageElement = document.createElement('div');
            messageElement.className = 'message assistant-message card border-light bg-light mb-3';
            messageElement.innerHTML = `
                <div class="card-header"><strong>${assistantName}</strong></div>
                <div class="card-body pb-0">${marked.parse(text)}</div>
            `;
            return messageElement;
        }

        // Function to prepend a message when displaying the initial thread
        function prependMessage(sender, text) {
            const conversationElement = document.getElementById('conversation');
            let messageElement;
            if (sender === 'user') {
                messageElement = renderUserMessageElement(text);
            } else {
                messageElement = renderAssistantMessageElement(sender, text);
            }
            conversationElement.insertBefore(messageElement, conversationElement.firstChild);
            scrollToBottom();
        }

        // Function to display a message in the conversation
        function displayMessage(sender, text) {
            const conversationElement = document.getElementById('conversation');
            let messageElement;
            if (sender === 'user') {
                messageElement = renderUserMessageElement(text);
            } else {
                messageElement = renderAssistantMessageElement(sender, text);
            }
            conversationElement.appendChild(messageElement);
            scrollToBottom();
        }

        // Function to create a new thread
        async function createThread(projectKey) {
            const url = 'https://api.openai.com/v1/threads';
            const options = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();
                console.log('Thread created:', data);
                return data.id;
            } catch (error) {
                console.error('Error creating thread:', error);
                alert('Failed to create thread.');
            }
        }

        async function fetchThreadFiles(projectKey, fileIds) {
            const files = [];
            for (const fileId of fileIds) {
                const url = `https://api.openai.com/v1/files/${fileId}`;
                const options = {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${projectKey}`,
                        'Content-Type': 'application/json',
                        'OpenAI-Beta': 'assistants=v2'
                    }
                };

                try {
                    const response = await fetch(url, options);
                    if (response.ok) {
                        const fileData = await response.json();
                        files.push(fileData);
                        displayFile(fileData);
                    } else {
                        console.error('Error fetching file:', fileId);
                    }
                } catch (error) {
                    console.error('Error fetching file:', fileId, error);
                }
            }
            console.log('Fetched files:', files);
        }

        // Function to validate an existing thread
        async function validateThread(projectKey, threadId) {
            const url = `https://api.openai.com/v1/threads/${threadId}`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    console.log('Thread is valid:', threadId);

                    const data = await response.json();
                    console.log('Thread data:', data);

                    // Fetch files if any
                    const fileIds = data.tool_resources.code_interpreter.file_ids;
                    if (fileIds.length > 0) {
                        await fetchThreadFiles(projectKey, fileIds);
                    }

                    return true;
                } else {
                    console.log('Thread is not valid:', threadId);
                    return false;
                }
            } catch (error) {
                console.error('Error validating thread:', error);
                return false;
            }
        }

        // Function to add a question to the thread
        async function addQuestionToThread(projectKey, questionText) {
            const url = `https://api.openai.com/v1/threads/${threadId}/messages`;
            const options = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                },
                body: JSON.stringify({ role: 'user', content: questionText })
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();
                console.log('Question added to thread:', data);
                return data;
            } catch (error) {
                console.error('Error adding question to thread:', error);
                alert('Failed to add question to thread.');
            }
        }

        // Function to create a run and get the response
        async function createRun(projectKey, responseTextElement) {
            const runUrl = `https://api.openai.com/v1/threads/${threadId}/runs`;
            const runOptions = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                },
                body: JSON.stringify({
                    assistant_id: selectedAssistantId,
                    stream: true
                })
            };

            try {
                const runResponse = await fetch(runUrl, runOptions);
                const decoder = new TextDecoder('utf-8');
                let fullContent = '';

                for await (const chunk of runResponse.body) {
                    const content = decoder.decode(chunk, { stream: true });
                    const lines = content.toString().split('\n').filter(line => line.trim() !== '');
                    const event = lines[0].replace(/^event: /, '');
                    let data;

                    console.log(event);
                    try {
                        console.log(JSON.parse(lines[1].replace(/^data: /, '')));
                    } catch {
                        console.log('Cannot parse');
                    }

                    if (event === 'thread.message.delta') {
                        data = JSON.parse(lines[1].replace(/^data: /, ''));
                        const deltaContent = data.delta.content[0];
                        if (deltaContent.type === 'text') {
                            let delta = deltaContent.text.value;
                            fullContent += delta;
                            responseTextElement.innerHTML = marked.parse(fullContent);
                        }
                    }

                    scrollToBottom();

                }
            } catch (error) {
                console.error('Error creating run:', error);
                alert('Failed to get response from assistant.');
                displayMessage(selectedAssistantName, 'An error occurred while fetching the response.');

                document.getElementById('submit-btn').disabled = false;
                document.getElementById('submit-btn').innerHTML = 'Submit';
            }
        }

        // Function to fetch and display messages from an existing thread
        async function fetchThreadMessages(projectKey, threadId) {
            const conversationElement = document.getElementById('conversation');
            conversationElement.innerHTML = `
                <div id="loading-conversation">
                    <span class="spinner-border spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </span> Loading conversation...
                </div>
            `;

            const url = `https://api.openai.com/v1/threads/${threadId}/messages`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();
                console.log('Thread messages:', data);

                conversationElement.innerHTML = '';

                if (data.data && data.data.length > 0) {
                    const messages = data.data;
                    for (const message of messages) {
                        const sender = message.role === 'user' ? 'user' : assistantDictionary[message.assistant_id];
                        let content = message.content[0].text.value;

                        const annotations = message.content[0].text.annotations;
                        for (let index = 0; index < annotations.length; index++) {
                            const annotation = annotations[index];
                            if (annotation.file_citation) {
                                const fileCitation = annotation.file_citation;
                                try {
                                    const citedFile = await fetchFileData(projectKey, fileCitation.file_id);
                                    const fileInfo = `(${citedFile.filename})`;
                                    content = content.replace(annotation.text, ` [${index + 1}] ${fileInfo}`);
                                } catch (error) {
                                    console.error(`File with id ${fileCitation.file_id} not found:`, error);
                                    content = content.replace(annotation.text, ' (Reference file is not available)');
                                }
                            } else if (annotation.file_path) {
                                const filePath = annotation.file_path;
                                const downloadLink = `download-url/${filePath.file_id}`; // TODO Add download function and link
                                content = content.replace(annotation.text, downloadLink);
                            }
                        }

                        prependMessage(sender, content);
                    }
                } else {
                    // Handle the case when there are no messages
                    console.log('no messages');
                    conversationElement.innerHTML = noMessagesDiv;
                }
            } catch (error) {
                console.error('Error fetching thread messages:', error);
                conversationElement.innerHTML = '<p>Failed to load conversation. Please try again later.</p>';
            }
        }
        // Function to initialize the session and create a thread if needed
        async function initializeSession() {
            const projectKey = getProjectKeyFromURL();
            const assistants = await fetchAssistants();  // Wait for assistants to be fetched

            if (assistants) {
                // Populate the assistant dictionary
                assistants.forEach(assistant => {
                    assistantDictionary[assistant.id] = assistant.name;
                });

                if (!threadId) {
                    // Clear the conversation area and show a message
                    document.getElementById('conversation').innerHTML = noMessagesDiv;

                    threadId = await createThread(projectKey);
                    sessionStorage.setItem('threadId', threadId);
                } else {
                    const isValidThread = await validateThread(projectKey, threadId);
                    if (!isValidThread) {
                        // Clear the conversation area and show a message
                        document.getElementById('conversation').innerHTML = noMessagesDiv;

                        threadId = await createThread(projectKey);
                        sessionStorage.setItem('threadId', threadId);
                    } else {
                        await fetchThreadMessages(projectKey, threadId);  // Fetch messages only after assistants are loaded
                    }
                }
            }
        }

        // Initialize the session and fetch assistants when the page loads
        window.addEventListener('load', async () => {
            await initializeSession();
            scrollToBottom();
        });

        // Function to reset the thread
        async function resetThread() {
            const projectKey = getProjectKeyFromURL();

            // Clear the conversation area and show a message
            document.getElementById('conversation').innerHTML = noMessagesDiv;
            // Create a new thread
            threadId = await createThread(projectKey);
            sessionStorage.setItem('threadId', threadId);

            // Clear any stored messages and reinitialize the session
            await initializeSession();
        }

        // Function to download all messages as a markdown file
        function downloadMessagesMd() {
            const conversationElement = document.getElementById('conversation');
            const messages = conversationElement.querySelectorAll('.message');
            let markdownContent = '';

            messages.forEach(message => {
                const sender = message.querySelector('strong').innerText;
                const content = message.innerHTML.replace(/<\/?[^>]+(>|$)/g, ""); // Remove HTML tags
                markdownContent += `**${sender}**\n${content}\n\n`;
            });

            const blob = new Blob([markdownContent], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'conversation.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // Function to download all messages as a DOCX file
        async function downloadMessagesDocx() {
            const { Document, Packer, Paragraph, TextRun } = window.docx;

            const conversationElement = document.getElementById('conversation');
            const messages = conversationElement.querySelectorAll('.message');

            const docChildren = [];

            messages.forEach(message => {
                const sender = message.querySelector('strong').innerText;
                const content = message.querySelector('.card-body') ? message.querySelector('.card-body').innerText : message.innerText;  // Get the inner text of the message

                const senderRun = new TextRun({
                    text: sender,
                    bold: true,
                });

                const contentRun = new TextRun({
                    text: content,
                });

                const paragraph = new Paragraph({
                    children: [senderRun, new TextRun("\n"), contentRun, new TextRun("\n\n")],
                });

                docChildren.push(paragraph);
            });

            const doc = new Document({
                sections: [
                    {
                        properties: {},
                        children: docChildren,
                    },
                ],
            });

            Packer.toBlob(doc).then(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'conversation.docx';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }).catch(err => {
                console.error('Error creating DOCX file:', err);
            });
        }


        // File uploads

        function displayFile(file) {
            const fileList = document.getElementById('file-list');
            const fileItem = document.createElement('li');
            fileItem.className = 'list-group-item';
            fileItem.innerText = `${file.filename} (${file.bytes} bytes)`;
            fileList.appendChild(fileItem);
        }

        Dropzone.autoDiscover = false; // Prevent Dropzone from auto discovering this element

        const dropzone = new Dropzone('#dropzone', {
            url: 'https://api.openai.com/v1/files',
            paramName: 'file', // The name that will be used to transfer the file
            maxFilesize: 512, // Maximum file size in MB
            headers: {
                'Authorization': `Bearer ${getProjectKeyFromURL()}`,
            },
            init: function() {
                this.on('sending', function(file, xhr, formData) {
                    formData.append('purpose', 'assistants');
                });
                this.on('success', function(file, response) {
                    console.log('File uploaded successfully:', response);
                    // Handle the response and add the file to the thread
                    const fileId = response.id;
                    addFilesToThread(getProjectKeyFromURL(), threadId, [fileId]);
                    displayFile(response);
                });
                this.on('error', function(file, errorMessage) {
                    console.error('Error uploading file:', errorMessage);
                    alert('Failed to upload file.');
                });
            }
        });

        async function fetchFileData(projectKey, fileId) {
            const url = `https://api.openai.com/v1/files/${fileId}`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    return await response.json();
                } else {
                    console.error('Error fetching file:', fileId);
                    return null;
                }
            } catch (error) {
                console.error('Error fetching file:', fileId, error);
                return null;
            }
        }

        async function getCurrentFileIds(projectKey, threadId) {
            const url = `https://api.openai.com/v1/threads/${threadId}`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    const data = await response.json();
                    return data.tool_resources.code_interpreter.file_ids || [];
                } else {
                    console.error('Error fetching thread:', threadId);
                    return [];
                }
            } catch (error) {
                console.error('Error fetching thread:', threadId, error);
                return [];
            }
        }

        async function addFilesToThread(projectKey, threadId, fileIds) {
            // Get the current file IDs
            const currentFileIds = await getCurrentFileIds(projectKey, threadId);

            // Combine current and new file IDs
            const combinedFileIds = currentFileIds.concat(fileIds);

            const url = `https://api.openai.com/v1/threads/${threadId}`;
            const options = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                },
                body: JSON.stringify({
                    tool_resources: {
                        code_interpreter: {
                            file_ids: combinedFileIds
                        }
                    }
                })
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Thread updated with files:', data);
                    alert('Files successfully uploaded and added to the thread.');
                } else {
                    console.error('Error updating thread with files.');
                    alert('Failed to add files to the thread.');
                }
            } catch (error) {
                console.error('Error updating thread with files:', error);
                alert('Failed to add files to the thread.');
            }
        }


    </script>
</body>
</html>
