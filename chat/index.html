<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>AI Assistants</title>

    <link href="https://fastly.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
    <link href="https://fastly.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/min/dropzone.min.css" integrity="sha512-WvVX1YO12zmsvTpUQV8s7ZU98DnkaAokcciMZJfnNWyNzm7//QRV61t4aEr0WdIa4pe854QHLTV302vH92FSMw==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        body {
            height: 100vh;
            margin: 0;
        }
        #assistants-list {
            overflow-y: auto;
        }
        #conversation {
            height: calc(100vh - 168px); /* Adjust based on navbar height */
            overflow-y: auto;
        }
        #question-form {
            display: flex;
        }
        #question {
            flex-grow: 1;
            margin-right: 10px;
        }
        #loading-conversation {
            text-align: center;
            margin: 40px;
        }
        #no-messages {
            text-align: center;
            margin: 40px;
        }
        .assistant-item {
            position: relative;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .assistant-info-icon {
            margin-left: 10px;
            cursor: pointer;
        }
        .list-group-item.active {
            background-color: #052c65;
            border-color: #052c65;
        }
        .dropzone {
            border: 2px dotted #cfe2ff;
            border-radius: 8px;
            background: #f8f9fa;
            padding: 20px;
            text-align: center;
        }
        .dropzone .dz-message {
            font-weight: normal;
            color: #007bff;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/min/dropzone.min.js" integrity="sha512-oQq8uth41D+gIH/NJvSJvVB85MFk1eWpMK6glnkg6I7EdMqC1XVkW7RxLheXwmFdG03qScCM7gKS/Cx3FYt7Tg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

</head>
<body>


<nav class="navbar bg-body-tertiary">
    <div class="container">
        <a class="navbar-brand" href="#">
            <span class="text-muted">Assistants</span>
        </a>

        <div class="d-flex">

            <div class="btn-group" role="group" aria-label="Basic example">
                <button class="btn btn-outline-secondary" onclick="downloadMessagesDocx()"
                       tabindex="0" data-bs-toggle="popover" data-bs-trigger="hover" data-bs-placement="auto"
                       data-bs-content="Click to download thread messages as a word file.">
                    <i class="bi bi-filetype-docx"></i>
                </button>
                <button class="btn btn-outline-secondary" onclick="downloadMessagesMd()"
                       tabindex="0" data-bs-toggle="popover" data-bs-trigger="hover" data-bs-placement="auto"
                       data-bs-content="Click to download thread messages as a markdown file.">
                    <i class="bi bi-filetype-md"></i>
                </button>
            </div>


            <button class="btn btn-outline-danger ms-2" onclick="resetThread()"
                   tabindex="0" data-bs-toggle="popover" data-bs-trigger="hover" data-bs-placement="auto"
                   data-bs-content="Click to reset this thread.">
                <i class="bi bi-x-lg"></i>
            </button>

        </div>

    </div>
</nav>


<div id="content" class="container mt-3">

    <div class="row">

        <div class="col-4">

            <div id="assistants-list" class="list-group">
                <div id="assistants-container" class="list-group">
                    <div id="loading-assistants" class="text-center">
                        <span class="spinner-border spinner-border-sm" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </span> Loading assistants...
                    </div>
                </div>
            </div>

            <ul id="file-list" class="list-group mt-3">
                <li class="list-group-item list-group-item-light text-dark">Data files</li>
                <li id="loading-files" class="list-group-item text-center" style="display: none;">
                    <span class="spinner-border spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </span> Loading files...
                </li>
            </ul>

            <div id="dropzone" class="dropzone mt-3">
                <div class="dz-message">Drop your data files here to upload.</div>
            </div>

        </div>


        <div class="col-8">

            <div id="conversation">

                <div id="loading-conversation">
                    <span class="spinner-border spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </span> Loading conversation...
                </div>

            </div>

        </div>

    </div>

</div>


<nav class="navbar fixed-bottom bg-body-white">
    <div class="container">
        <div id="question-form" class="offset-4 w-100 my-2 ps-2">
            <textarea id="question" class="form-control" rows="2" placeholder="Type your question here..."></textarea>
            <button id="submit-btn" class="btn btn-secondary" onclick="submitQuestion()">Submit</button>
        </div>
    </div>
</nav>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js" integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            var popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
            var popoverList = popoverTriggerList.map(function (popoverTriggerEl) {
                return new bootstrap.Popover(popoverTriggerEl, {
                    trigger: 'hover'
                });
            });

            document.getElementById('question').addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    if (e.shiftKey) {
                        // Allow new line if Shift key is pressed
                        return;
                    } else {
                        e.preventDefault();
                        // Submit the question
                        submitQuestion();
                    }
                }
            });
        });

        let selectedAssistantId = null;
        let selectedAssistantName = null;
        let assistantDictionary = {};
        let threadId = sessionStorage.getItem('threadId');
        const noMessagesDiv = `
                    <div id="no-messages">
                        <p>No messages in this thread yet.</p>
                        <p>Start the conversation by asking a question.</p>
                    </div>
                `;

        // Function to get the project key from the URL hash parameter
        function getProjectKeyFromURL() {
            const hash = window.location.hash;
            if (hash.startsWith('#')) {
                return hash.substring(1);
            }
            return null;
        }

        // Function to fetch the list of assistants
        async function fetchAssistants() {
            const projectKey = getProjectKeyFromURL();
            if (!projectKey) {
                document.getElementById('assistants-container').innerText = 'Project key not found in URL.';
                document.getElementById('conversation').innerText = '';
                return;
            }

            const url = 'https://api.openai.com/v1/assistants';
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();

                if (!data.data) {
                    throw new Error('Assistants data is not defined');
                }

                await displayAssistants(projectKey, data.data);

                return data.data;  // Return the assistants data

            } catch (error) {
                console.error('Error fetching assistants:', error);
                document.getElementById('assistants-list').innerText = `Failed to fetch assistants: ${error.message}`;
            }
        }

        // Function to display the list of assistants
        async function displayAssistants(projectKey, assistants) {
            const containerElement = document.getElementById('assistants-container');
            containerElement.innerHTML = '';

            if (assistants.length === 0) {
                containerElement.innerText = 'No assistants found.';
                return;
            }

            assistants.reverse().forEach((assistant, index) => {
                assistantDictionary[assistant.id] = assistant.name;

                const description = assistant.description ? `<span class="small">${assistant.description}</span>` : '';
                const instructions = assistant.instructions ? `<p><strong>Instructions:</strong> ${assistant.instructions}</p>` : '';
                const model = assistant.model ? `<p><strong>Model:</strong> ${assistant.model}</p>` : '';
                const tools = assistant.tools && assistant.tools.length > 0 ?
                    `<p><strong>Tools:</strong> ${assistant.tools.map(tool => tool.type).join(', ')}</p>` : '';

                const assistantElement = document.createElement('a');
                assistantElement.className = 'list-group-item list-group-item-action assistant-item';
                assistantElement.dataset.id = assistant.id;
                assistantElement.innerHTML = `
                    <div>
                        <strong class="d-block">${assistant.name}</strong>
                        ${description}
                    </div>
                    <i class="bi bi-info-circle assistant-info-icon" tabindex="0" data-bs-toggle="popover" data-bs-content="${instructions}${model}${tools}" data-html="true"></i>
                `;
                assistantElement.onclick = () => {
                    // Check if the clicked assistant is the same as the already selected one
                    if (selectedAssistantId === assistant.id) {
                        return; // Do nothing if the same assistant is clicked
                    }
                    selectAssistant(projectKey, assistants, assistant.id, assistant.name, assistantElement);
                };
                containerElement.appendChild(assistantElement);

                // Initialize Bootstrap Popover with html: true
                const popover = new bootstrap.Popover(assistantElement.querySelector('.assistant-info-icon'), {
                    html: true,
                    trigger: 'hover'
                });

                // Set initial popover content
                const isSelected = index === 0 ? '<p class="text-success"><i>Selected as your assistant.</i></p>' : '<p class="text-secondary"><i>Not selected. Click to select as your assistant.</i></p>';
                popover.setContent({ '.popover-body': `${isSelected}${instructions}${model}${tools}` });

                // Select the first assistant by default
                if (index === 0) {
                    selectAssistant(projectKey, assistants, assistant.id, assistant.name, assistantElement);
                }
            });
        }

        // Function to select an assistant
        async function selectAssistant(projectKey, assistants, assistantId, assistantName, element) {
            selectedAssistantId = assistantId;
            selectedAssistantName = assistantName;

            // Set the selected assistant element as active
            const assistantElements = document.querySelectorAll('.list-group-item');
            assistantElements.forEach(el => el.classList.remove('active'));
            element.classList.add('active');

            // Update Bootstrap Popovers to reflect the selected status
            await updateAssistantTooltips(projectKey, assistants);

            console.log(`Selected Assistant ID: ${assistantId}`);
        }

        // Function to update assistant tooltips with file information
        async function updateAssistantTooltips(projectKey, assistants) {
            const assistantElements = document.querySelectorAll('.list-group-item');
            const promises = Array.from(assistantElements).map(async (el) => {
                const assistantInfoIcon = el.querySelector('.assistant-info-icon');
                if (assistantInfoIcon) {
                    const popover = bootstrap.Popover.getInstance(assistantInfoIcon);
                    if (popover) {
                        const assistant = assistants.find(a => a.id === el.dataset.id);
                        let files = '';

                        if (assistant && assistant.tool_resources.file_search.vector_store_ids.length > 0) {
                            const vectorStoreId = assistant.tool_resources.file_search.vector_store_ids[0];
                            const fileNames = await fetchAssistantFiles(projectKey, vectorStoreId);
                            files = fileNames.length > 0
                                ? `<p><strong>Files:</strong></p><ul>${fileNames.map(fileName => `<li>${fileName}</li>`).join('')}</ul>`
                                : '';
                        }

                        const instructions = assistant.instructions ? `<p><strong>Instructions:</strong><p></p> ${assistant.instructions}</p>` : '';
                        const model = assistant.model ? `<p><strong>Model:</strong> ${assistant.model}</p>` : '';
                        const tools = assistant.tools && assistant.tools.length > 0 ?
                            `<p><strong>Tools:</strong> ${assistant.tools.map(tool => tool.type).join(', ')}</p>` : '';
                        const isSelected = el.dataset.id === selectedAssistantId ? '<p class="text-success"><i>Selected as your assistant.</i></p>' : '<p class="text-secondary"><i>Not selected. Click to select as your assistant.</i></p>';
                        popover.setContent({ '.popover-body': `${isSelected}${instructions}${model}${tools}${files}` });
                    }
                }
            });

            await Promise.all(promises);
        }

        // Function to fetch assistant files from the vector store
        async function fetchAssistantFiles(projectKey, vectorStoreId) {
            const url = `https://api.openai.com/v1/vector_stores/${vectorStoreId}/files`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                const fileList = await response.json();

                if (response.ok) {
                    const fileIds = fileList.data.map(file => file.id);
                    const fileNames = await fetchFileNames(projectKey, fileIds);
                    return fileNames;
                } else {
                    console.error('Error fetching assistant files:', fileList);
                    return [];
                }
            } catch (error) {
                console.error('Error fetching assistant files:', error);
                return [];
            }
        }

        // Function to fetch filenames
        async function fetchFileNames(projectKey, fileIds) {
            const promises = fileIds.map(async fileId => {
                const url = `https://api.openai.com/v1/files/${fileId}`;
                const options = {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${projectKey}`,
                        'Content-Type': 'application/json',
                        'OpenAI-Beta': 'assistants=v2'
                    }
                };

                try {
                    const response = await fetch(url, options);
                    const fileData = await response.json();

                    if (response.ok) {
                        return fileData.filename;
                    } else {
                        console.error('Error fetching file:', fileData);
                        return null;
                    }
                } catch (error) {
                    console.error('Error fetching file:', error);
                    return null;
                }
            });

            try {
                const fileNames = await Promise.all(promises);
                return fileNames.filter(name => name !== null);
            } catch (error) {
                console.error('Error fetching file names:', error);
                return [];
            }
        }

        // Function to scroll to the bottom of the conversation
        function scrollToBottom() {
            const conversationElement = document.getElementById('conversation');
            conversationElement.scrollTop = conversationElement.scrollHeight;
        }

        // Function to submit a question
        async function submitQuestion() {
            const projectKey = getProjectKeyFromURL();
            const questionText = document.getElementById('question').value.trim();

            // Check if the textarea is not empty before submitting
            if (!selectedAssistantId || !questionText) {
                alert('Please select an assistant and enter a question.');
                return;
            }

            // Remove the no-messages div if it exists
            const noMessagesDiv = document.getElementById('no-messages');
            if (noMessagesDiv) {
                noMessagesDiv.remove();
            }

            // Disable submit button and add spinner
            const submitButton = document.getElementById('submit-btn');
            submitButton.disabled = true;
            submitButton.innerHTML = 'Submit <div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Loading...</span></div>';

            displayMessage('user', questionText);

            await addQuestionToThread(projectKey, questionText);

            document.getElementById('question').value = '';

            // Create an empty assistant response element
            const assistantResponseElement = renderAssistantMessageElement(selectedAssistantName, '');
            document.getElementById('conversation').appendChild(assistantResponseElement);

            // Select the response text element within the assistant message element
            const responseTextElement = assistantResponseElement.querySelector('.message-body');
            await createRun(projectKey, responseTextElement);

            // Enable submit button and remove spinner
            submitButton.disabled = false;
            submitButton.innerHTML = 'Submit';
        }

        function renderUserMessageElement(text) {
            const messageElement = document.createElement('div');
            messageElement.className = 'message user-message offset-2 alert alert-secondary mb-3';
            messageElement.innerHTML = `${text}`;
            return messageElement;
        }

        function renderAssistantMessageElement(assistantName, text) {
            const messageElement = document.createElement('div');
            messageElement.className = 'message assistant-message alert alert-light mb-3';
            messageElement.innerHTML = `
                <h6 class="alert-heading">${assistantName}</h6>
                <div class="message-body">${marked.parse(text)}</div>
            `;
            return messageElement;
        }

        // Function to prepend a message when displaying the initial thread
        function prependMessage(sender, text) {
            const conversationElement = document.getElementById('conversation');
            let messageElement;
            if (sender === 'user') {
                messageElement = renderUserMessageElement(text);
            } else {
                messageElement = renderAssistantMessageElement(sender, text);
            }
            conversationElement.insertBefore(messageElement, conversationElement.firstChild);
            scrollToBottom();
        }

        // Function to display a message in the conversation
        function displayMessage(sender, text) {
            const conversationElement = document.getElementById('conversation');
            let messageElement;
            if (sender === 'user') {
                messageElement = renderUserMessageElement(text);
            } else {
                messageElement = renderAssistantMessageElement(sender, text);
            }
            conversationElement.appendChild(messageElement);
            scrollToBottom();
        }

        // Function to create a new thread
        async function createThread(projectKey) {
            const url = 'https://api.openai.com/v1/threads';
            const options = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();
                console.log('Thread created:', data);
                return data.id;
            } catch (error) {
                console.error('Error creating thread:', error);
                alert('Failed to create thread.');
            }
        }

        async function fetchThreadFiles(projectKey, fileIds) {
            const fileListElement = document.getElementById('file-list');
            const promises = fileIds.map(fileId => {
                const url = `https://api.openai.com/v1/files/${fileId}`;
                const options = {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${projectKey}`,
                        'Content-Type': 'application/json',
                        'OpenAI-Beta': 'assistants=v2'
                    }
                };
                return fetch(url, options).then(response => response.json()).catch(error => {
                    console.error('Error fetching file:', fileId, error);
                    return null;
                });
            });

            try {
                const files = await Promise.all(promises);
                const validFiles = files.filter(file => file !== null);

                console.log('Fetched files:', validFiles);

                if (validFiles.length > 0) {
                    validFiles.forEach(file => displayFile(file));
                } else {
                    fileListElement.innerHTML += '<li class="list-group-item text-muted">No files available.</li>';
                }
            } catch (error) {
                console.error('Error fetching files:', error);
                fileListElement.innerHTML += '<li class="list-group-item text-muted">Failed to load files.</li>';
            }
        }

        async function listThreadFiles(projectKey, threadId) {
            const fileList = document.getElementById('file-list')
            const loadingFilesElement = document.getElementById('loading-files');
            loadingFilesElement.style.display = 'block'; // Show loading-files

            const url = `https://api.openai.com/v1/threads/${threadId}`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    const data = await response.json();
                    const fileIds = data.tool_resources.code_interpreter.file_ids;
                    if (fileIds.length > 0) {
                        await fetchThreadFiles(projectKey, fileIds);
                    } else {
                         fileList.innerHTML += '<li class="list-group-item text-muted">No files available.</li>';
                    }
                } else {
                    console.error('Error fetching thread files:', threadId);
                    fileList.innerHTML += '<li class="list-group-item text-muted">Failed to load files.</li>';
                }
            } catch (error) {
                console.error('Error fetching thread files:', error);
                fileList.innerHTML += '<li class="list-group-item text-muted">Failed to load files.</li>';
            }  finally {
                loadingFilesElement.style.display = 'none'; // Hide loading-files after fetching files
            }
        }

        // Function to validate an existing thread
        async function validateThread(projectKey, threadId) {
            const url = `https://api.openai.com/v1/threads/${threadId}`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    console.log('Thread is valid:', threadId);
                    return true;
                } else {
                    console.log('Thread is not valid:', threadId);
                    return false;
                }
            } catch (error) {
                console.error('Error validating thread:', error);
                return false;
            }
        }

        // Function to add a question to the thread
        async function addQuestionToThread(projectKey, questionText) {
            const url = `https://api.openai.com/v1/threads/${threadId}/messages`;
            const options = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                },
                body: JSON.stringify({ role: 'user', content: questionText })
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();
                console.log('Question added to thread:', data);
                return data;
            } catch (error) {
                console.error('Error adding question to thread:', error);
                alert('Failed to add question to thread.');
            }
        }

        // Function to create a run and get the response
        async function createRun(projectKey, responseTextElement) {
            const runUrl = `https://api.openai.com/v1/threads/${threadId}/runs`;
            const runOptions = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                },
                body: JSON.stringify({
                    assistant_id: selectedAssistantId,
                    stream: true
                })
            };

            try {
                const runResponse = await fetch(runUrl, runOptions);
                const decoder = new TextDecoder('utf-8');
                let fullContent = '';

                for await (const chunk of runResponse.body) {
                    const content = decoder.decode(chunk, { stream: true });
                    const lines = content.toString().split('\n').filter(line => line.trim() !== '');
                    const event = lines[0].replace(/^event: /, '');
                    let data;

                    console.log(event);
                    try {
                        console.log(JSON.parse(lines[1].replace(/^data: /, '')));
                    } catch {
                        console.log('Cannot parse');
                    }

                    if (event === 'thread.message.delta') {
                        data = JSON.parse(lines[1].replace(/^data: /, ''));
                        const deltaContent = data.delta.content[0];
                        if (deltaContent.type === 'text') {
                            let delta = deltaContent.text.value;
                            fullContent += delta;
                            responseTextElement.innerHTML = marked.parse(fullContent);
                        }
                    }

                    scrollToBottom();

                }
            } catch (error) {
                console.error('Error creating run:', error);
                alert('Failed to get response from assistant.');
                displayMessage(selectedAssistantName, 'An error occurred while fetching the response.');

                document.getElementById('submit-btn').disabled = false;
                document.getElementById('submit-btn').innerHTML = 'Submit';
            }
        }

        // Function to fetch and display messages from an existing thread
        async function fetchThreadMessages(projectKey, threadId) {
            const conversationElement = document.getElementById('conversation');
            conversationElement.innerHTML = `
                <div id="loading-conversation">
                    <span class="spinner-border spinner-border-sm" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </span> Fetching messages...
                </div>
            `;

            const url = `https://api.openai.com/v1/threads/${threadId}/messages`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                const data = await response.json();
                console.log('Thread messages:', data);

                conversationElement.innerHTML = '';

                if (data.data && data.data.length > 0) {
                    const messages = data.data;
                    for (const message of messages) {
                        const sender = message.role === 'user' ? 'user' : assistantDictionary[message.assistant_id];
                        let content = message.content[0].text.value;

                        const annotations = message.content[0].text.annotations;
                        for (let index = 0; index < annotations.length; index++) {
                            const annotation = annotations[index];
                            if (annotation.file_citation) {
                                const fileCitation = annotation.file_citation;
                                try {
                                    const citedFile = await fetchFileData(projectKey, fileCitation.file_id);
                                    const fileInfo = `(${citedFile.filename})`;
                                    content = content.replace(annotation.text, ` [${index + 1}] ${fileInfo}`);
                                } catch (error) {
                                    console.error(`File with id ${fileCitation.file_id} not found:`, error);
                                    content = content.replace(annotation.text, ' (Reference file is not available)');
                                }
                            } else if (annotation.file_path) {
                                const filePath = annotation.file_path;
                                const downloadLink = `download-url/${filePath.file_id}`; // TODO Add download function and link
                                content = content.replace(annotation.text, downloadLink);
                            }
                        }

                        prependMessage(sender, content);
                    }
                } else {
                    // Handle the case when there are no messages
                    console.log('no messages');
                    conversationElement.innerHTML = noMessagesDiv;
                }
            } catch (error) {
                console.error('Error fetching thread messages:', error);
                conversationElement.innerHTML = '<p>Failed to load conversation. Please try again later.</p>';
            }
        }

        // Function to initialize the session and create a thread if needed
        async function initializeSession() {
            const projectKey = getProjectKeyFromURL();
            const assistants = await fetchAssistants();  // Wait for assistants to be fetched

            if (assistants) {
                // Populate the assistant dictionary
                assistants.forEach(assistant => {
                    assistantDictionary[assistant.id] = assistant.name;
                });

                if (!threadId) {
                    // Clear the conversation area and show a message
                    document.getElementById('conversation').innerHTML = noMessagesDiv;

                    threadId = await createThread(projectKey);
                    sessionStorage.setItem('threadId', threadId);
                } else {
                    const isValidThread = await validateThread(projectKey, threadId);
                    if (!isValidThread) {
                        // Clear the conversation area and show a message
                        document.getElementById('conversation').innerHTML = noMessagesDiv;

                        threadId = await createThread(projectKey);
                        sessionStorage.setItem('threadId', threadId);
                    } else {
                        await fetchThreadMessages(projectKey, threadId);  // Fetch messages only after assistants are loaded
                        await listThreadFiles(projectKey, threadId);  // List thread files separately
                    }
                }
                // Fetch assistant files after initialization
                await updateAssistantTooltips(projectKey, assistants);
            }
        }

        // Initialize the session and fetch assistants when the page loads
        window.addEventListener('load', async () => {
            await initializeSession();
            scrollToBottom();
        });

        // Function to reset the thread
        async function resetThread() {
            const projectKey = getProjectKeyFromURL();

            // Clear the conversation area and show a message
            document.getElementById('conversation').innerHTML = noMessagesDiv;
            // Create a new thread
            threadId = await createThread(projectKey);
            sessionStorage.setItem('threadId', threadId);

            // Clear any stored messages and reinitialize the session
            await initializeSession();
        }

        // Function to download all messages as a markdown file
        function downloadMessagesMd() {
            const conversationElement = document.getElementById('conversation');
            const messages = conversationElement.querySelectorAll('.message');
            let markdownContent = '';

            messages.forEach(message => {
                let sender, content;
                if (message.classList.contains('user-message')) {
                    sender = 'User';
                    content = message.innerText;
                } else if (message.classList.contains('assistant-message')) {
                    sender = message.querySelector('.alert-heading').innerText;
                    content = message.querySelector('.message-body').innerText;
                } else {
                    // If message does not match expected classes, skip it
                    return;
                }

                markdownContent += `**${sender}**\n${content}\n\n`;
            });

            const blob = new Blob([markdownContent], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'conversation.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // Function to download all messages as a DOCX file
        async function downloadMessagesDocx() {
            const { Document, Packer, Paragraph, TextRun } = window.docx;

            const conversationElement = document.getElementById('conversation');
            const messages = conversationElement.querySelectorAll('.message');

            const docChildren = [];

            messages.forEach(message => {
                let sender, content;
                if (message.classList.contains('user-message')) {
                    sender = 'User';
                    content = message.innerText;
                } else if (message.classList.contains('assistant-message')) {
                    sender = message.querySelector('.alert-heading').innerText;
                    content = message.querySelector('.message-body').innerText;
                } else {
                    // If message does not match expected classes, skip it
                    return;
                }

                const senderRun = new TextRun({
                    text: sender,
                    bold: true,
                });

                const contentRun = new TextRun({
                    text: content,
                });

                const paragraph = new Paragraph({
                    children: [senderRun, new TextRun("\n"), contentRun, new TextRun("\n\n")],
                });

                docChildren.push(paragraph);
            });

            const doc = new Document({
                sections: [
                    {
                        properties: {},
                        children: docChildren,
                    },
                ],
            });

            Packer.toBlob(doc).then(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'conversation.docx';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }).catch(err => {
                console.error('Error creating DOCX file:', err);
            });
        }

        // File uploads

        function displayFile(file) {
            const fileList = document.getElementById('file-list');
            const fileItem = document.createElement('li');
            fileItem.className = 'list-group-item';
            fileItem.innerHTML = `<small>${file.filename} (${file.bytes} bytes)<\small>`;
            fileList.appendChild(fileItem);
        }

        Dropzone.autoDiscover = false; // Prevent Dropzone from auto discovering this element

        const dropzone = new Dropzone('#dropzone', {
            url: 'https://api.openai.com/v1/files',
            paramName: 'file', // The name that will be used to transfer the file
            maxFilesize: 512, // Maximum file size in MB
            maxFiles: 20, // Maximum number of files
            headers: {
                'Authorization': `Bearer ${getProjectKeyFromURL()}`,
            },
            init: function() {
                this.on('sending', function(file, xhr, formData) {
                    formData.append('purpose', 'assistants');
                });
                this.on('success', function(file, response) {
                    console.log('File uploaded successfully:', response);
                    // Handle the response and add the file to the thread
                    const fileId = response.id;
                    addFilesToThread(getProjectKeyFromURL(), threadId, [fileId]);
                    displayFile(response);
                });
                this.on('error', function(file, errorMessage) {
                    console.error('Error uploading file:', errorMessage);
                    alert('Failed to upload file.');
                });
            }
        });

        async function fetchFileData(projectKey, fileId) {
            const url = `https://api.openai.com/v1/files/${fileId}`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    return await response.json();
                } else {
                    console.error('Error fetching file:', fileId);
                    return null;
                }
            } catch (error) {
                console.error('Error fetching file:', fileId, error);
                return null;
            }
        }

        async function getCurrentFileIds(projectKey, threadId) {
            const url = `https://api.openai.com/v1/threads/${threadId}`;
            const options = {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                }
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    const data = await response.json();
                    return data.tool_resources.code_interpreter.file_ids || [];
                } else {
                    console.error('Error fetching thread:', threadId);
                    return [];
                }
            } catch (error) {
                console.error('Error fetching thread:', threadId, error);
                return [];
            }
        }

        async function addFilesToThread(projectKey, threadId, fileIds) {
            // Get the current file IDs
            const currentFileIds = await getCurrentFileIds(projectKey, threadId);

            // Combine current and new file IDs
            const combinedFileIds = currentFileIds.concat(fileIds);

            const url = `https://api.openai.com/v1/threads/${threadId}`;
            const options = {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${projectKey}`,
                    'Content-Type': 'application/json',
                    'OpenAI-Beta': 'assistants=v2'
                },
                body: JSON.stringify({
                    tool_resources: {
                        code_interpreter: {
                            file_ids: combinedFileIds
                        }
                    }
                })
            };

            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Thread updated with files:', data);
                    alert('Files successfully uploaded and added to the thread.');
                } else {
                    console.error('Error updating thread with files.');
                    alert('Failed to add files to the thread.');
                }
            } catch (error) {
                console.error('Error updating thread with files:', error);
                alert('Failed to add files to the thread.');
            }
        }

    </script>
</body>
</html>
